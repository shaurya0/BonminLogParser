{-# LANGUAGE OverloadedStrings, DeriveDataTypeable, RecordWildCards #-}

module Main where

import BonminLogParser
import Data.Attoparsec.ByteString.Char8
import qualified Data.ByteString.Char8 as B
import Data.Either
import System.Console.CmdArgs
import System.Directory
import System.FilePath
import System.Environment
import System.Exit
import Control.Monad (when)

data MyOptions = MyOptions {inputFilePath :: FilePath, outputFilePath :: FilePath} deriving (Data, Typeable, Show, Eq)

myProgOpts :: MyOptions
myProgOpts = MyOptions
    { inputFilePath = def &= typFile &= help "path to inputfile"
    , outputFilePath = def &= typFile &= help "path to outputfile"
    }


getOpts :: IO MyOptions
getOpts  = cmdArgs $ myProgOpts
    &= summary (_PROGRAM_INFO )
    &= help _PROGRAM_ABOUT
    &= helpArg [explicit, name "help", name "h"]
    &= program _PROGRAM_NAME

_PROGRAM_NAME :: String
_PROGRAM_NAME = "BonminLogParser"
_PROGRAM_VERSION :: String
_PROGRAM_VERSION = "0.1"
_PROGRAM_INFO :: String
_PROGRAM_INFO = _PROGRAM_NAME ++ " version " ++ _PROGRAM_VERSION
_PROGRAM_ABOUT :: String
_PROGRAM_ABOUT = "Parses a Bonmin log output generated by e.g ./bonmin some_minlp.nl > log_some_minlp.txt"

filePath1 :: FilePath
filePath1 = "/home/shaurya/Development/BonminLogParser/data/sample_log.txt"

filePath2 :: FilePath
filePath2 = "/home/shaurya/Development/BonminLogParser/data/sample_log2.txt"

filePath3 :: FilePath
filePath3 = "/home/shaurya/Development/BonminLogParser/data/sample_log3.txt"

getLastNLines :: B.ByteString -> Int -> [B.ByteString]
getLastNLines contents n =
    let lineContents = reverse $ B.lines contents
        lastNLines = Prelude.take n lineContents
    in lastNLines


optionHandler :: MyOptions -> IO ()
optionHandler opts@MyOptions{..}  = do
    fileExists <- doesFileExist inputFilePath
    let dir = takeDirectory outputFilePath
    dirGood <- doesDirectoryExist dir
    when (not fileExists) $ putStrLn ("the file " ++ inputFilePath ++  ": does not exist") >> exitWith (ExitFailure 1)
    when (not dirGood) $ putStrLn ("the directory of the outputfile " ++ outputFilePath ++  ": does not exist") >> exitWith (ExitFailure 1)
    results <- parseBonminLog inputFilePath
    putStrLn $ show results

parseBonminLog :: FilePath -> IO (BonminResults)
parseBonminLog filePath = do
    contents <- B.readFile filePath
    let lastLines = reverse $ getLastNLines contents 10
    let results =  map (parseOnly bonminResultsParser) lastLines
    let retval = map (parseOnly bonminSolverReturnParser) lastLines
    let u = head $ rights results
    let t = head $ rights retval
    let v = u {solverReturn =  t}
    return v



main :: IO()
main = do
    args <- getArgs
    opts <- (if null args then withArgs ["--help"] else id) getOpts
    optionHandler opts

